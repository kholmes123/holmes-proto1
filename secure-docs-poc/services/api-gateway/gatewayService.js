// gatewayService.js uses FormData to send redacted text and other metadata to docxRedactionService.js.
// The redaction service then builds a redacted .docx file from that text.

const express = require('express');
const multer = require('multer');
const axios = require('axios');
const fs = require('fs-extra');
const path = require('path');
const app = express();
const cors = require('cors');
app.use(express.static(path.join(__dirname, 'public')));
const dotenv = require('dotenv');
const FormData = require('form-data');

dotenv.config();
const upload = multer({ dest: 'uploads/' });

app.use(cors());
app.use(express.json());

app.post('/process-docx', upload.single('file'), async (req, res) => {
  try {
    const engine = req.body.engine || 'regex';
    const filePath = path.resolve(req.file.path);

    const originalFilename = req.file?.originalname || 'unknown.docx';

    const form = new FormData();
    form.append('file', fs.createReadStream(filePath)); // âœ… the actual file
    form.append('originalFilename', originalFilename);  // âœ… just metadata, not a file itself
    

    let detectionUrl;
    if (engine === 'regex') {
      detectionUrl = 'http://localhost:3007/detect-pii-docx';
    } else if (engine === 'nlp') {
      detectionUrl = 'http://localhost:3009/detect-nlp-docx';
    } else {
      return res.status(400).json({ error: 'Unsupported PII detection engine specified.' });
    }

    // Step 1: Detect PII
    const detectResponse = await axios.post(detectionUrl, form, { headers: form.getHeaders() });
    const { redactedText, mappings, genericFilename } = detectResponse.data;

    // Step 2: Forward to Redaction Service
    const redactionForm = new FormData();
    redactionForm.append('file', fs.createReadStream(filePath));  // â¬…ï¸ Becomes `req.file` within Express
    redactionForm.append('redactedText', redactedText); // â¬…ï¸ Becomes `req.body.redactedText`
    redactionForm.append('genericFilename', genericFilename); // this is the generic filename generated by the detection service. It becomes `req.body.genericFilename`

    // OPTIONAL - Debug logging of the file sending
    console.log('DEBUG: About to send file to detection service');
    console.log('File exists:', fs.existsSync(filePath));
    console.log('Detection URL:', detectionUrl);
    console.log('Form headers:', form.getHeaders());

    // END DEBUG LOGGING

    const redactResponse = await axios.post(
      'http://localhost:3006/redaction/redact-docx',
      redactionForm,
      { headers: redactionForm.getHeaders(), responseType: 'stream' }
    );

    fs.unlinkSync(filePath);

    // update the response headers to include the anonymized filename
    res.setHeader('Content-Disposition', `attachment; filename="${genericFilename}"`);
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
    
    redactResponse.data.pipe(res);
  } catch (err) {
    console.error('Gateway error:', err);
    res.status(500).json({ error: 'Processing failed', details: err.message });
  }
});

// Endpoint for watermarking
// This endpoint is used to process a DOCX file, detect PII, redact it, and then apply a watermark.
// It uses the same upload middleware as the previous endpoint.
// It expects a file and an optional engine parameter in the request body.
// The engine parameter determines which PII detection engine to use (regex or nlp).
// The file is uploaded to a temporary location, and the original filename is preserved.
// The file is then sent to the appropriate PII detection service.
// After PII detection, the redacted text is sent to the redaction service.
// Finally, the redacted file is sent to the watermarking service.
// The response includes the download path for the redacted file and the watermark verification data.

app.post('/process-docx-watermark', upload.single('file'), async (req, res) => {
    try {
      const engine = req.body.engine || 'regex';
      const filePath = path.resolve(req.file.path);
      const originalFilename = req.file?.originalname || 'unknown.docx';
  
      const form = new FormData();
      form.append('file', fs.createReadStream(filePath));
      form.append('originalFilename', originalFilename);
  
      const detectionUrl = engine === 'nlp'
        ? 'http://localhost:3009/detect-nlp-docx'
        : 'http://localhost:3007/detect-pii-docx';
  
      // Step 1: PII Detection
      const detectResponse = await axios.post(detectionUrl, form, { headers: form.getHeaders() });
      const { redactedText, mappings, genericFilename } = detectResponse.data;
  
      // Step 2: Redaction
      const redactionForm = new FormData();
      redactionForm.append('file', fs.createReadStream(filePath));
      redactionForm.append('redactedText', redactedText);
      redactionForm.append('genericFilename', genericFilename);
  
      // DEBUG: adding some log outputs to check the file being sent for redaction. The name must be a string or an error happens
      console.log('ðŸ›°ï¸ SENDING TO REDACTION SERVICE...');
      console.log('ðŸ“„ File path:', filePath);
      console.log('ðŸ“„ File exists:', fs.existsSync(filePath));
      console.log('ðŸ“ redactedText (preview):', redactedText.slice(0, 200)); // First 200 characters
      console.log('ðŸ“› genericFilename:', genericFilename);

      // Send the file to the redaction service
      // The redaction service will handle the file and redacted text
      // and return the redacted file.
      // The responseType is set to 'arraybuffer' to handle binary data
      // and the file is saved to a temporary location.
      // The redacted file is saved to a temporary location.
     
      
      const redactedResponse = await axios.post(
        'http://localhost:3006/redaction/redact-docx',
        redactionForm,
        { headers: redactionForm.getHeaders(), responseType: 'arraybuffer' }
      );
  
      const redactedPath = path.resolve(__dirname, 'temp', genericFilename);
      fs.ensureDirSync(path.dirname(redactedPath));
      fs.writeFileSync(redactedPath, redactedResponse.data);
  
      // Step 3: Watermarking
      const watermarkPayload = {
        originalFilename,
        redactedFilePath: redactedPath,
        genericFilename
      };
      // Debug
      console.log ('kicking off watermarking service with payload:', watermarkPayload);
      
      const watermarkResponse = await axios.post(
        'http://localhost:3012/watermark/embedWatermark',
        watermarkPayload,
        { headers: { 'Content-Type': 'application/json' } }
      );
  
      // Cleanup original upload
      fs.unlinkSync(filePath);

      //capture the verification status and extracted text as variables from the response to the API call
      const {
        verification,
        watermarkText: extractedWatermarkText
      } = watermarkResponse.data;
  
      res.status(200).json({
        message: 'âœ… Watermarked file created.',
        watermarkVerified: verification ,
        extractedWatermarkText,
        originalFilename,
        genericFilename,
      });
    } catch (err) {
      console.error('âŒ Full chain failed:', err.message);
      res.status(500).json({
        error: 'Full document processing chain failed',
        details: err.message
      });
    }
  });

const PORT = process.env.PORT || 3010;
app.listen(PORT, () => console.log(`Gateway service running on port ${PORT}`));
